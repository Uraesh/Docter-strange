<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Dr Strange Hand Control - Three.js + MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* Vidéo webcam (cachée ou visible en petit pour debug, ici cachée pour l'immersion) */
        .input_video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); opacity: 0; pointer-events: none;
        }

        /* Canvas Three.js */
        canvas {
            display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1); /* Miroir pour correspondre aux mouvements de la main */
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffaa00; font-family: 'Courier New', monospace; font-size: 1.5em; 
            text-align: center; pointer-events: none; z-index: 10;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Initialisation de la Magie...<br><span style="font-size:0.6em">Autorisez la caméra</span></div>
    
    <div id="container">
        <video class="input_video"></video>
        </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- VARIABLES GLOBALES DE CONTRÔLE ---
        let handPosition = new THREE.Vector3(0, 0, 0); // Position cible
        let handRotation = new THREE.Quaternion(); // Rotation cible
        let handDetected = false;
        let isFist = false; // État destruction
        
        // État du cercle (0 = détruit, 1 = complet)
        let magicIntegrity = 0; 

        // --- PARTIE 1 : THREE.JS (Le Visuel) ---
        const scene = new THREE.Scene();
        // Pas de fond noir total, on laisse transparent pour voir la vidéo si besoin, 
        // ou noir pour immersion totale. Ici noir.
        scene.background = new THREE.Color(0x050505); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('container').appendChild(renderer.domElement);

        // Post-Processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.5; 
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- GÉNÉRATION TEXTURES (Copié du code précédent) ---
        function createRuneTexture(textString) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.translate(512, 512);
            ctx.font = 'bold 80px Courier New';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const step = (Math.PI * 2) / textString.length;
            for (let i = 0; i < textString.length; i++) {
                ctx.save();
                ctx.rotate(i * step);
                ctx.translate(0, -380);
                ctx.fillText(textString[i], 0, 0);
                ctx.restore();
            }
            ctx.beginPath(); ctx.arc(0, 0, 430, 0, Math.PI * 2);
            ctx.lineWidth = 10; ctx.strokeStyle = 'white'; ctx.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        function createSquareTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = 'white'; ctx.lineWidth = 15;
            ctx.strokeRect(100, 100, 312, 312);
            ctx.lineWidth = 5; ctx.beginPath();
            ctx.moveTo(100, 100); ctx.lineTo(412, 412);
            ctx.moveTo(412, 100); ctx.lineTo(100, 412);
            ctx.stroke();
            return new THREE.CanvasTexture(canvas);
        }

        // --- ASSEMBLAGE DU CERCLE ---
        const magicGroup = new THREE.Group();
        scene.add(magicGroup);
        const materialBase = { transparent: true, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false };

        const runeRing = new THREE.Mesh(new THREE.PlaneGeometry(6, 6), new THREE.MeshBasicMaterial({ ...materialBase, map: createRuneTexture("ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789"), color: 0xffaa00 }));
        magicGroup.add(runeRing);

        const runeRing2 = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), new THREE.MeshBasicMaterial({ ...materialBase, map: createRuneTexture("⚡ ★ ☀ ☂ ☁ ☾ ☝ ☠ ☮ ☯ ☢ ☣"), color: 0xff4400 }));
        magicGroup.add(runeRing2);

        const squareRing = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 3.5), new THREE.MeshBasicMaterial({ ...materialBase, map: createSquareTexture(), color: 0xffcc00 }));
        magicGroup.add(squareRing);

        // --- PARTIE 2 : MEDIAPIPE (La Vision) ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const loadingDiv = document.getElementById('loading');

        function onResults(results) {
            loadingDiv.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. POSITION : On utilise le point 9 (base du majeur) comme centre de la main
                const palmCenter = landmarks[9];
                
                // Conversion coordonnées normalisées (0->1) vers coordonnées Three.js (-w -> +w)
                // On utilise un champ de vision approximatif à Z=0
                const x = (palmCenter.x - 0.5) * 18; // Multiplicateur pour couvrir l'écran
                const y = -(palmCenter.y - 0.5) * 14;
                
                // Lissage simple
                handPosition.set(x, y, 0);

                // 2. DÉTECTION POING FERMÉ vs MAIN OUVERTE
                // On compare la distance du bout des doigts (Index 8) par rapport au poignet (0)
                const wrist = landmarks[0];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                
                // Distance simple au carré pour éviter la racine carrée
                const dIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                const dMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
                const dRing = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y);
                
                const avgDist = (dIndex + dMiddle + dRing) / 3;

                // Seuil empirique : si les doigts sont proches du poignet, c'est un poing
                isFist = avgDist < 0.25; 

            } else {
                handDetected = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraUtils.start();

        // --- PARTIE 3 : ANIMATION ET LOGIQUE DE JEU ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // 1. Gestion de l'intégrité (Construction / Destruction)
            // Si main détectée et pas poing -> Construire (tendre vers 1)
            // Si poing ou pas de main -> Détruire (tendre vers 0)
            const targetIntegrity = (handDetected && !isFist) ? 1.0 : 0.0;
            
            // Interpolation douce (Lerp) pour l'effet de construction
            magicIntegrity += (targetIntegrity - magicIntegrity) * 5 * dt;

            // 2. Mouvement du Groupe
            if (handDetected) {
                // Suivre la main (avec un peu de retard pour la fluidité)
                magicGroup.position.lerp(handPosition, 0.1);
                
                // Inclinaison subtile basée sur la position (effet de perspective)
                magicGroup.rotation.x = THREE.MathUtils.lerp(magicGroup.rotation.x, handPosition.y * 0.1, 0.1);
                magicGroup.rotation.y = THREE.MathUtils.lerp(magicGroup.rotation.y, handPosition.x * 0.1, 0.1);
            }

            // 3. Animation visuelle basée sur l'intégrité
            
            // Échelle : De 0 à 1.2 (léger rebond)
            const scale = magicIntegrity * (1 + Math.sin(elapsedTime * 10) * 0.02); 
            magicGroup.scale.set(scale, scale, scale);

            // Rotation des anneaux
            // Si on détruit (integrity < 1), ça tourne très vite façon "panne d'énergie"
            const chaosSpeed = (1.1 - magicIntegrity) * 10; 
            
            runeRing.rotation.z += (0.5 + chaosSpeed) * dt;
            runeRing2.rotation.z -= (0.3 + chaosSpeed) * dt;
            squareRing.rotation.z += (0.2 + chaosSpeed) * dt;

            // Opacité et couleur
            // On module l'intensité du bloom
            bloomPass.strength = 1.5 + (1 - magicIntegrity) * 5; // Flash lumineux quand on détruit
            
            // Masquer si intégrité proche de 0
            magicGroup.visible = magicIntegrity > 0.01;

            composer.render();
        }

        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
